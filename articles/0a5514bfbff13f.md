---
title: "読書感想文-Linuxのしくみ"
emoji: "🍣"
type: "tech"
topics: ["linux", "読書"]
published: false
---

# はじめに

[Linux のしくみ カーネルを知ってステップアップ]()を呼みました。その中で覚えておきたいキーワードや概念を、書籍の目次順でまとめます。

# Linux の概要

「カーネルがなぜ必要か」、「システムコールとは何か」などの基本的な内容が書かれている。
概念は知っているがそれを確認するためのいくつかの下記のコマンドが紹介されており、知らないものや使ったことがないものもあった。

## strace

発行したシステムコールを確認する。

- `-T`オプションでシステムコールの所要時間をマイクロ秒で出力できるため、ボトルネックの処理があるときの調査などで使えそう。

```bash
$ strace -T -o <出力ファイル> <コマンド>
```

## sar

論理 CPU が実行している命令の割合を確認する。
ユーザーモード、カーネルモード、アイドル状態など、それぞれの比率を確認できる。

- `-P 0`は論理 CPU0 を表す
- その次の`1`は 1 秒ごとにデータを採取する意味
- その次の`1`は 1 回だけデータを採取する意味

```bash
$ sar -P 0 1 1
```

## taskset

任意のコマンドを指定した論理 CPU で実行する。

```bash
$ taskset -c <論理CPU番号> <コマンド>
```

### ldd

実行ファイルにリンクされているライブラリを確認できる。
python など多くの言語は C の上で動いていることは知っていたが、以下コマンドで標準 C ライブラリがリンクされていることを実際に確認した。

```
$ ldd /usr/bin/python3
```

静的リンクというのもあり、ビルド時に実行ファイル内にライブラリの関数を組み込みます。
`golang`の実行ファイルは基本的には静的リンクで、`ldd`で確認すると共有リンクがないことが分かる。
(私の環境では`golang`の実行ファイルでも、共有ライブラリがリンクされているものもあった。)
静的リンクが使用される理由は以下。

- サイズが多くなりがちだが、現代の PC ならそれほどの大きな問題ではない。
- 別の環境での実行も容易
- 実行時の共有ライブラリリンクがないため速い
- 共有ライブラリのアップデートで発生しがちな、「DLL 地獄」を回避できる。

# プロセス管理(基礎編)

## プロセスの終了

プロセスにはいくつかの状態がある。その中で終了時の挙動で知らなかったことがあったためそのあたりのメモ。

子プロセスの終了後、親プロセスは wait などのシステムコールにより以下の情報を得る。

- プロセスの終了ステータス。256 の余り値。exit(0)などを指定するとそのまま 0 が返る。一般に 0 が成功、1 が失敗かな？
- シグナルによって終了したかどうか。
- 使用した CPU 時間。

書籍にあった以下のサンプルコードで動作を確認。

- false は 1(異常終了)を常に返す、それをバックグラウンド実行
- wait で待ち合わせ、`$!`で最後のバックグラウンドジョブのプロセス ID を指定
- `$?`で終了ステータスを取得

```bash
#!/bin/bash
false &
wait $!
echo "falseコマンドが終了しました: $?"
```

https://qiita.com/laikuaut/items/1daa06900ad045d119b4
https://shellscript.sunone.me/exit_status.html

## ゾンビプロセスと孤児プロセス

名前は聞いたことはあったが、具体的にどんな状況でこのようなプロセスになるのか知らなかった。

**ゾンビプロセス**
プロセスは終了したのに、親プロセスから wait 系システムコールが呼ばれていない状態

**孤児プロセス**
wait 系システムコールを呼ばずに、親プロセスが死んだ状態。init が親になる。
「ゾンビプロセスが init プロセスに襲い掛かる」という書籍の表現が面白い

## シグナル

`ctrl`+`c`で送られるシグナルは SIGINT だが、これは`kill -INT <pid>`でも送れるらしい。その他いくつか知らないシグナルがあった。

| シグナル |                                 効果                                 |
| :------: | :------------------------------------------------------------------: |
| SIGCHLD  | 子プロセス終了で親プロセスに送る。これで wait 系システムコールを呼ぶ |
| SIGSTOP  |                 `ctrl`+`z`と同じ、プロセスの一時停止                 |
| SIGCONT  |                            SIGSTOP の再開                            |

## ジョブ、セッション、プロセスグループ

端末や ssh を識別したり、プロセスを識別したり、複数のプロセスをまとめて扱う仕組み
うまく活用することで以下のようなことができる。

- プロセスグループにまとめて signal を送る
- 端末を閉じても実行したプロセスを終了させない。 (キーワード：nohup, disown)

## デーモン

常駐プロセスという理解で良さそう。親プロセスが init である。
ssh のサーバー側のプロセスである sshd とかは常に動いていないと行けないのでデーモンである。
(大学生の時に出会ったおじさんエンジニアに、「デーモンも知らないのか」って鼻で笑われたな・・・)

# プロセススケジューラ

## タイムスライス

一つの論理 CPU で同時に実行できるプロセスは一つだけ。
CPU はタイムスライスという単位で、複数のプロセスの実行を切り替えている。
(キーワード：nice 値)

## コンテキストスイッチ

CPU 上で実行されているプロセスが切り替わること。
プログラムを書くときは、こういう動作があることも頭に入れておきたい。(これに起因するバグの例とかあるのかな？)

## 並列実行の重要性

論理 CPU のシングルスレッド性能が頭打ちになってきている。論理 CPU の数は増えたのでこれを意識するべきである。

# メモリ管理システム

キーワード：仮想記憶、ページテーブル、ページフォールト、デマンドページング

## 仮想記憶

物理メモリを直接プロセスが参照すると発生する問題を解決するために、仮想記憶をはさむ。仮想記憶と物理メモリの対応表がページテーブル。
ページテーブルの一行サイズは CPU アーキテクチャ毎に異なるらしい。

## デマンドページング

プロセスは先に仮想記憶のアドレスだけ取得する。実際に使用するときにページフォールトが発生し、物理アドレスを取得する。そもそも仮想記憶外にアクセス仕様とした場合は参照エラー。(c や go などではよくあるやつ)

https://zenn.dev/satoru_takeuchi/articles/bdbdeceea00a2888c580

# プロセス管理(応用編)

## コピーオンライト

fork などでプロセス生成した際に、ページテーブルだけコピーする機能。コストが少なくて済む。

## プロセス間通信

キーワード：共有メモリ、シグナル、パイプ、ソケット

## 排他制御

キーワード：「compare and exchange」、「compare and swap」、ピーターソンのアルゴリズム

lock ファイルを使ったおなじみの排他制御とその問題点が説明されている。よく考えれば「lock ファイルの有無を確認」というクリティカルセッションがアトミックになっていないためである。
CPU ではアトミックに実行する処理がある。詳しくはキーワードで調べてみる。

## マルチプロセスとマルチスレッド

マルチプロセスは`fork`や`execve`で新プロセスを作って、プロセス間通信を行う。
マルチスレッドは一つのプロセス内に複数の流れを作るイメージで、POSIX には標準 API として POSIX スレッドがある。

マルチプロセスと比較して、起動速い、リソース消費が少ないなどあるが、一方で 1 スレッドが他全てに影響する、スレッドセーフを意識する必要があったりする。
スレッドとは厳密には異なるけど、この辺のマルチスレッドライクなプログラミングを簡単に行えるように coroutine や goroutine があるという認識。(coroutine は他にも中断可能という概念で同期的に書くことができたりもするけど)

# デバイスアクセス

# ファイルシステム

# 記憶階層

# ブロック層

# 仮想化機能

# コンテナ

# cgroup

# 今後
