---
title: "読書感想文-Linuxのしくみ"
emoji: "🍣"
type: "tech"
topics: ["linux", "読書"]
published: false
---

# はじめに

[Linux のしくみ カーネルを知ってステップアップ]()を呼みました。その中で覚えておきたいキーワードや概念を、書籍の目次順でまとめます。

# Linux の概要

「カーネルがなぜ必要か」、「システムコールとは何か」などの基本的な内容が書かれている。
概念は知っているがそれを確認するためのいくつかの下記のコマンドが紹介されており、知らないものや使ったことがないものもあった。

## strace

発行したシステムコールを確認する。

- `-T`オプションでシステムコールの所要時間をマイクロ秒で出力できるため、ボトルネックの処理があるときの調査などで使えそう。

```bash
$ strace -T -o <出力ファイル> <コマンド>
```

## sar

論理 CPU が実行している命令の割合を確認する。
ユーザーモード、カーネルモード、アイドル状態など、それぞれの比率を確認できる。

- `-P 0`は論理 CPU0 を表す
- その次の`1`は 1 秒ごとにデータを採取する意味
- その次の`1`は 1 回だけデータを採取する意味

```bash
$ sar -P 0 1 1
```

## taskset

任意のコマンドを指定した論理 CPU で実行する。

```bash
$ taskset -c <論理CPU番号> <コマンド>
```

### ldd

実行ファイルにリンクされているライブラリを確認できる。
python など多くの言語は C の上で動いていることは知っていたが、以下コマンドで標準 C ライブラリがリンクされていることを実際に確認した。

```
$ ldd /usr/bin/python3
```

静的リンクというのもあり、ビルド時に実行ファイル内にライブラリの関数を組み込みます。
`golang`の実行ファイルは基本的には静的リンクで、`ldd`で確認すると共有リンクがないことが分かる。
(私の環境では`golang`の実行ファイルでも、共有ライブラリがリンクされているものもあった。)
静的リンクが使用される理由は以下。

- サイズが多くなりがちだが、現代の PC ならそれほどの大きな問題ではない。
- 別の環境での実行も容易
- 実行時の共有ライブラリリンクがないため速い
- 共有ライブラリのアップデートで発生しがちな、「DLL 地獄」を回避できる。

# プロセス管理(基礎編)

## プロセスの終了

プロセスにはいくつかの状態がある。その中で終了時の挙動で知らなかったことがあったためそのあたりのメモ。

子プロセスの終了後、親プロセスは wait などのシステムコールにより以下の情報を得る。

- プロセスの終了ステータス。256 の余り値。exit(0)などを指定するとそのまま 0 が返る。一般に 0 が成功、1 が失敗かな？
- シグナルによって終了したかどうか。
- 使用した CPU 時間。

書籍にあった以下のサンプルコードで動作を確認。

- false は 1(異常終了)を常に返す、それをバックグラウンド実行
- wait で待ち合わせ、`$!`で最後のバックグラウンドジョブのプロセス ID を指定
- `$?`で終了ステータスを取得

```bash
#!/bin/bash
false &
wait $!
echo "falseコマンドが終了しました: $?"
```

https://qiita.com/laikuaut/items/1daa06900ad045d119b4
https://shellscript.sunone.me/exit_status.html

## ゾンビプロセスと孤児プロセス

名前は聞いたことはあったが、具体的にどんな状況でこのようなプロセスになるのか知らなかった。

**ゾンビプロセス**
プロセスは終了したのに、親プロセスから wait 系システムコールが呼ばれていない状態

**孤児プロセス**
wait 系システムコールを呼ばずに、親プロセスが死んだ状態。init が親になる。
「ゾンビプロセスが init プロセスに襲い掛かる」という書籍の表現が面白い

## シグナル

`ctrl`+`c`で送られるシグナルは SIGINT だが、これは`kill -INT <pid>`でも送れるらしい。その他いくつか知らないシグナルがあった。

| シグナル |                                 効果                                 |
| :------: | :------------------------------------------------------------------: |
| SIGCHLD  | 子プロセス終了で親プロセスに送る。これで wait 系システムコールを呼ぶ |
| SIGSTOP  |                 `ctrl`+`z`と同じ、プロセスの一時停止                 |
| SIGCONT  |                            SIGSTOP の再開                            |

## ジョブ、セッション、プロセスグループ

端末や ssh を識別したり、プロセスを識別したり、複数のプロセスをまとめて扱う仕組み
うまく活用することで以下のようなことができる。

- プロセスグループにまとめて signal を送る
- 端末を閉じても実行したプロセスを終了させない。 (キーワード：nohup, disown)

## デーモン

常駐プロセスという理解で良さそう。親プロセスが init である。
ssh のサーバー側のプロセスである sshd とかは常に動いていないと行けないのでデーモンである。
(大学生の時に出会ったおじさんエンジニアに、「デーモンも知らないのか」って鼻で笑われたな・・・)

# プロセススケジューラ

## タイムスライス

一つの論理 CPU で同時に実行できるプロセスは一つだけ。
CPU はタイムスライスという単位で、複数のプロセスの実行を切り替えている。
(キーワード：nice 値)

## コンテキストスイッチ

CPU 上で実行されているプロセスが切り替わること。
プログラムを書くときは、こういう動作があることも頭に入れておきたい。(これに起因するバグの例とかあるのかな？)

## 並列実行の重要性

論理 CPU のシングルスレッド性能が頭打ちになってきている。論理 CPU の数は増えたのでこれを意識するべきである。

# メモリ管理システム

キーワード：仮想記憶、ページテーブル、ページフォールト、デマンドページング

## 仮想記憶

物理メモリを直接プロセスが参照すると発生する問題を解決するために、仮想記憶をはさむ。仮想記憶と物理メモリの対応表がページテーブル。
ページテーブルの一行サイズは CPU アーキテクチャ毎に異なるらしい。

## デマンドページング

プロセスは先に仮想記憶のアドレスだけ取得する。実際に使用するときにページフォールトが発生し、物理アドレスを取得する。そもそも仮想記憶外にアクセス仕様とした場合は参照エラー。(c や go などではよくあるやつ)

https://zenn.dev/satoru_takeuchi/articles/bdbdeceea00a2888c580

# プロセス管理(応用編)

## コピーオンライト

fork などでプロセス生成した際に、ページテーブルだけコピーする機能。コストが少なくて済む。

## プロセス間通信

キーワード：共有メモリ、シグナル、パイプ、ソケット

## 排他制御

:::message
キーワード：
・compare and exchange
・compare and swap
・ピーターソンのアルゴリズム
:::

lock ファイルを使ったおなじみの排他制御とその問題点が説明されている。よく考えれば「lock ファイルの有無を確認」というクリティカルセッションがアトミックになっていないためである。
CPU ではアトミックに実行する処理がある。詳しくはキーワードで調べてみる。

## マルチプロセスとマルチスレッド

マルチプロセスは`fork`や`execve`で新プロセスを作って、プロセス間通信を行う。
マルチスレッドは一つのプロセス内に複数の流れを作るイメージで、POSIX には標準 API として POSIX スレッドがある。

マルチプロセスと比較して、起動速い、リソース消費が少ないなどあるが、一方で 1 スレッドが他全てに影響する、スレッドセーフを意識する必要があったりする。
スレッドとは厳密には異なるけど、この辺のマルチスレッドライクなプログラミングを簡単に行えるように coroutine や goroutine があるという認識。(coroutine は他にも中断可能という概念で同期的に書くことができたりもするけど)

# デバイスアクセス

## デバイスファイル

- デバイスにアクセスするためのファイル
- `/dev/`以下にある

`echo hello > /dev/pts/n`とかやれば他の端末にシステムコールを発行できる。

# ファイルシステム

ファイルシステムはファイルという単位で良い感じに管理してくれる。代表的なものとして、`ext4`や`XFS`、`Btrfs`などがある。ただ POSIX にこれらを扱う標準 API があるため、ユーザーはその違いを意識しなくて良い。
ファイルシステムの一般的な機能の中で、アプリプログラマが知ってると良いと思ったのは以下の機能。

- 容量制限(クォータ)・・ディレクトリ単位で最大容量を決めたりなど
- 整合性保持・・読み書き中に電源が切れてもなんとかする技術

:::message
キーワード：
・ジャーナリング(整合性保持のためのアイデアの一つ)
・コピーオンライト(整合性保持のためのアイデアの一つ)
:::

## 様々なファイルシステム

システムの現在の状態について把握できる様々なファイルシステムが提供されていて、面白い。今まで適当に見ていた Linux のディレクトリも実はシステム情報を表すファイルシステムだったりした。

- メモリベースのファイルシステム・・`/tmp`や`var/run`などに作られる、作ることができる。
- ネットワークファイルシステム・・NFS や CIFS など。
- `procsfs`
  - `/proc`以下にマウントされる。
  - `proc/<pid>/cmdline`で実行されたコマンドラインを確認できる(他にもプロセスに関しての情報が詰まっている)

# 記憶階層

## キャッシュメモリ

メモリの内容を一時的に CPU 側のキャッシュメモリに置いておくことで処理の高速化を目指す。
CPU 実行時に、メモリとレジスタ間のデータ交換が遅いので、キャッシュメモリが CPU 側に入る。キャッシュメモリはその中で L1,L2..のように分かれている場合があり、L1 の方が速いが容量が小さいとトレードオフ。

## ページキャッシュとバッファキャッシュ

ページキャッシュはファイルを一時的にメモリに置いておくことで処理の高速化を目指す。
バッファキャッシュはファイル以外のキャッシュを行う。

## スワップ

メモリが枯渇してきたら、あまり使用していなさそうなメモリをストレージデバイス内のスワップ領域に移動する。ストレージアクセスになると処理が遅くなるが、OOM が発動するよりはマシという感じか。

# ブロック層

ブロックデバイス(ストレージデバイス)の性能を引き出すための Linux カーネルの機能。
HDD が磁気で何かしているのは知っていたけど、半径方向と円周方向に広がる磁気ディスクのセクタという領域毎にスイングアームの動きを調整して、データを取得している話を知れて面白かった。
電子ではなく物理的なのでそりゃ遅くなるかと思いつつ、なるべくスイングアームの動く量が少なくなるようにカーネルが頑張っていることを知って話のネタにできそう。

:::message
キーワード：
・I/O スケジューラ
・先読み(readahead)
:::

# 仮想化機能

# コンテナ

# cgroup

# 今後
